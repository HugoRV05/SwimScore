import { useState, useMemo } from 'react';
import { useAppStore } from '../lib/store';
import { Link } from 'react-router-dom';
import { Search, ChevronDown, ChevronUp, Trophy } from 'lucide-react';
import Select from '../components/ui/Select';
import { useLanguage } from '../context/LanguageContext';

export default function ClubRankings() {
  const { meet, scoringConfig, clubStandings } = useAppStore();
  const { t } = useLanguage();
  const [sortBy, setSortBy] = useState<'total' | 'individual' | 'relay' | 'medals'>('total');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  const [searchTerm, setSearchTerm] = useState('');
  const [expandedClub, setExpandedClub] = useState<string | null>(null);
  
  // Filters
  const [categoryFilter, setCategoryFilter] = useState<string>('all');
  const [genderFilter, setGenderFilter] = useState<string>('all');

  const computedStandings = useMemo(() => {
    if (!meet) return [];

    const clubMap = new Map<string, {
      id: string;
      name: string;
      shortName?: string;
      individualPoints: number;
      relayPoints: number;
      goldMedals: number;
      silverMedals: number;
      bronzeMedals: number;
      swimmerCount: number; // This is tricky with filters, maybe just count swimmers contributing?
    }>();

    // Initialize clubs from clubStandings (which acts as our club registry)
    clubStandings.forEach(standing => {
      clubMap.set(standing.club.id, {
        id: standing.club.id,
        name: standing.club.name,
        shortName: standing.club.shortName,
        individualPoints: 0,
        relayPoints: 0,
        goldMedals: 0,
        silverMedals: 0,
        bronzeMedals: 0,
        swimmerCount: 0 
      });
    });

    const contributingSwimmers = new Map<string, Set<string>>(); // clubId -> Set<swimmerId>

    meet.events.forEach(event => {
      // Event Level Filters (e.g. if filtering by Gender 'Male', ignore 'Female' events?)
      // Actually strictly speaking, Gender filter usually applies to the Swimmer/Relay gender.
      // But for simplicity, we look at results.
      
      event.results.forEach(result => {
        // Filter Logic
        let include = true;

        // Gender Filter
        if (genderFilter !== 'all') {
          // If event is mixed, we might need to check swimmer gender? 
          // Result doesn't currently store swimmer gender snapshot, need to look up swimmer or event gender.
          // For relays, event gender is usually definitive.
          // For individuals, we can use swimmer object if available.
          if (event.isRelay) {
             if (event.gender !== 'mixed' && event.gender !== genderFilter) include = false;
             // If mixed relay, do we include in Male/Female points? Usually no, or split?
             // User request: "just u14 man points". Usually implies filtering out Mixed.
             if (event.gender === 'mixed') include = false; 
          } else {
             const swimmerGender = result.swimmer?.gender || event.gender;
             if (swimmerGender !== genderFilter) include = false;
          }
        }

        // Category Filter
        // "Just U14 points" -> This implies using the category points OR 
        // if the swimmer IS U14, include their open points too?
        // Usually "U14 Points" means points counted TOWARDS the U14 category.
        // However, "U14 total" might mean all points scored by U14 swimmers.
        // Let's assume: Points scored IN that category + Open points scored BY swimmers of that category?
        // OR just points in that category column?
        // Given the prompt "just u14 points", likely means "Category Eligible Points where Category = U14".
        
        // Wait, complicating this too much. Let's simplify:
        // If filter is 'u14':
        // Include result IF result.swimmerCategory == 'u14' AND (result.categoryPoints > 0 OR result.openPoints > 0)
        // Adjust points: Take BOTH open and cat points? Or just cat?
        // Usually club rankings are (Total Open Pts + Total Cat Pts).
        // So we sum everything generated by U14 swimmers.
        
        if (categoryFilter !== 'all') {
           // Fix: Relays count as Open
           if (categoryFilter === 'open' && event.isRelay) {
             // Keep included
           } else if (result.swimmerCategory !== categoryFilter) {
             include = false;
           }
        }

        if (!include) return;

        const club = clubMap.get(result.club.id);
        if (!club) return;

        // Points
        // We sum Open + Category points for the selected subset
        // Note: This logic assumes we want to see "How many points did U14s contribute to the club?"
        // Points: Open + Category + Bonus
        let points = (result.openPoints || 0) + (result.categoryPoints || 0);
        
        if ((result.openEligible || result.categoryEligible) && result.bonusPoints) {
          points += result.bonusPoints;
        }
        
        if (event.isRelay) {
          club.relayPoints += points;
        } else {
          club.individualPoints += points;
          if (result.swimmer) {
             if (!contributingSwimmers.has(club.id)) contributingSwimmers.set(club.id, new Set());
             contributingSwimmers.get(club.id)!.add(result.swimmer.id);
          }
        }

        // Medals (only if points > 0? or position 1-3 regardless? Usually regardless of points)
        // But if we filter "U14 points", maybe we only want U14 medals.
        if (result.position === 1) club.goldMedals++;
        if (result.position === 2) club.silverMedals++;
        if (result.position === 3) club.bronzeMedals++;
      });
    });

    // Update swimmer counts
    contributingSwimmers.forEach((swimmers, clubId) => {
      const club = clubMap.get(clubId);
      if (club) club.swimmerCount = swimmers.size;
    });

    return Array.from(clubMap.values()).map(c => ({
      ...c,
      totalPoints: c.individualPoints + c.relayPoints
    }));

  }, [meet, categoryFilter, genderFilter]);
  
  const sortedStandings = useMemo(() => {
    let standings = [...computedStandings];
    
    // Filter by search
    if (searchTerm) {
      standings = standings.filter(s => 
        s.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Sort
    standings.sort((a, b) => {
      let aVal: number, bVal: number;
      switch (sortBy) {
        case 'individual':
          aVal = a.individualPoints;
          bVal = b.individualPoints;
          break;
        case 'relay':
          aVal = a.relayPoints;
          bVal = b.relayPoints;
          break;
        case 'medals':
          aVal = a.goldMedals * 100 + a.silverMedals * 10 + a.bronzeMedals;
          bVal = b.goldMedals * 100 + b.silverMedals * 10 + b.bronzeMedals;
          break;
        default:
          aVal = a.totalPoints;
          bVal = b.totalPoints;
      }
      return sortDirection === 'desc' ? bVal - aVal : aVal - bVal;
    });
    
    return standings;
  }, [computedStandings, sortBy, sortDirection, searchTerm]);
  
  const handleSort = (column: typeof sortBy) => {
    if (sortBy === column) {
      setSortDirection(d => d === 'desc' ? 'asc' : 'desc');
    } else {
      setSortBy(column);
      setSortDirection('desc');
    }
  };
  
  const SortIcon = ({ column }: { column: typeof sortBy }) => {
    if (sortBy !== column) return null;
    return sortDirection === 'desc' ? <ChevronDown size={14} /> : <ChevronUp size={14} />;
  };
  
  if (!meet) {
    return (
      <div>
        <header className="page-header">
          <h1 className="page-title">{t('clubRankings.title')}</h1>
          <p className="page-subtitle">{t('clubRankings.subtitle')}</p>
        </header>
        
        <div className="empty-state">
          <div className="empty-state-icon">
            <Trophy strokeWidth={1.5} />
          </div>
          <h3>{t('clubRankings.empty.title')}</h3>
          <p>{t('clubRankings.empty.message')}</p>
          <Link to="/upload" className="btn btn-primary">
            {t('common.uploadPdf')}
          </Link>
        </div>
      </div>
    );
  }

  // Generate category options based on meet data would be ideal, but hardcoded is safer for now
  // Assuming 'u14' | 'junior' | 'open' are the keys
  
  return (
    <div>
      <header className="page-header">
        <h1 className="page-title">{t('clubRankings.title')}</h1>
        <p className="page-subtitle">
          {t('clubRankings.subtitleWithMeet', { meet: meet.name, count: clubStandings.length, scoring: scoringConfig.name })}
        </p>
      </header>
      
      {/* Filters */}
      <div className="filters">
        <div className="filter-group" style={{ flex: 1, maxWidth: '250px' }}>
          <label>{t('clubRankings.filters.search')}</label>
          <div style={{ position: 'relative' }}>
            <Search size={16} style={{ position: 'absolute', left: '12px', top: '50%', transform: 'translateY(-50%)', color: 'var(--color-text-muted)' }} />
            <input
              type="text"
              placeholder={t('clubRankings.filters.searchPlaceholder')}
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              style={{ paddingLeft: '36px' }}
            />
          </div>
        </div>
        
        <div className="filter-group" style={{ width: '180px' }}>
          <label>{t('clubRankings.filters.category')}</label>
          <Select 
            value={categoryFilter}
            onChange={setCategoryFilter}
            options={[
              { value: 'all', label: t('common.allCategories') },
              { value: 'open', label: t('common.open') },
              { value: 'junior', label: t('common.junior') },
              { value: 'u14', label: 'U14' }
            ]}
          />
        </div>

        <div className="filter-group" style={{ width: '180px' }}>
          <label>{t('clubRankings.filters.gender')}</label>
          <Select 
            value={genderFilter}
            onChange={setGenderFilter}
            options={[
              { value: 'all', label: t('common.allGenders') },
              { value: 'male', label: t('common.male') },
              { value: 'female', label: t('common.female') }
            ]}
          />
        </div>
      </div>
      
      {/* Rankings Table */}
      <div className="card">
        <div className="table-container">
          <table>
            <thead>
              <tr>
                <th>{t('common.pos')}</th>
                <th>{t('common.club')}</th>
                <th 
                  onClick={() => handleSort('individual')} 
                  style={{ cursor: 'pointer', userSelect: 'none' }}
                >
                  <span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                    {t('clubRankings.table.individual')} <SortIcon column="individual" />
                  </span>
                </th>
                <th 
                  onClick={() => handleSort('relay')} 
                  style={{ cursor: 'pointer', userSelect: 'none' }}
                >
                  <span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                    {t('clubRankings.table.relay')} <SortIcon column="relay" />
                  </span>
                </th>
                <th 
                  onClick={() => handleSort('total')} 
                  style={{ cursor: 'pointer', userSelect: 'none' }}
                >
                  <span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                    {t('clubRankings.table.total')} <SortIcon column="total" />
                  </span>
                </th>
                <th 
                  onClick={() => handleSort('medals')} 
                  style={{ cursor: 'pointer', userSelect: 'none' }}
                >
                  <span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                    {t('clubRankings.table.medals')} <SortIcon column="medals" />
                  </span>
                </th>
                <th>{t('clubRankings.table.swimmers')}</th>
              </tr>
            </thead>
            <tbody>
              {sortedStandings.map((standing, index) => (
                <tr 
                  key={standing.id}
                  onClick={() => setExpandedClub(
                    expandedClub === standing.id ? null : standing.id
                  )}
                  style={{ cursor: 'pointer' }}
                >
                  <td>
                    <span className={`position-badge ${index < 3 ? `position-${index + 1}` : ''}`}>
                      {index + 1}
                    </span>
                  </td>
                  <td>
                    <strong>{standing.name}</strong>
                  </td>
                  <td>{standing.individualPoints.toFixed(0)}</td>
                  <td>{standing.relayPoints.toFixed(0)}</td>
                  <td className="points">{standing.totalPoints.toFixed(0)}</td>
                  <td>
                    <div className="medals">
                      {standing.goldMedals > 0 && <span className="medal medal-gold">G {standing.goldMedals}</span>}
                      {standing.silverMedals > 0 && <span className="medal medal-silver">S {standing.silverMedals}</span>}
                      {standing.bronzeMedals > 0 && <span className="medal medal-bronze">B {standing.bronzeMedals}</span>}
                      {standing.goldMedals === 0 && standing.silverMedals === 0 && standing.bronzeMedals === 0 && <span style={{ color: 'var(--color-text-muted)' }}>-</span>}
                    </div>
                  </td>
                  <td>{standing.swimmerCount}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
      
      {/* Summary Stats */}
      <div className="stats-grid" style={{ marginTop: 'var(--space-6)' }}>
        <div className="stat-card">
          <div className="stat-content">
            <h3>{sortedStandings.reduce((sum, s) => sum + s.totalPoints, 0).toFixed(0)}</h3>
            <p>{t('clubRankings.stats.totalPointsView')}</p>
          </div>
        </div>
        <div className="stat-card">
          <div className="stat-content">
            <h3>{sortedStandings.reduce((sum, s) => sum + s.goldMedals, 0)}</h3>
            <p>{t('clubRankings.stats.goldMedalsView')}</p>
          </div>
        </div>
      </div>
    </div>
  );
}
